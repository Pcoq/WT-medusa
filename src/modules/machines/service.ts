import {
  Context,
  DAL,
  InferEntityType,
  InternalModuleDeclaration,
  ModuleJoinerConfig,
  ModulesSdkTypes,
} from "@medusajs/framework/types"
import {
  InjectManager,
  InjectTransactionManager,
  MedusaContext,
  MedusaService,
} from "@medusajs/framework/utils"
import Machine from "./models/machine"
import { joinerConfig } from "./joiner-config"
import { 
  MachineDTO, 
  CreateMachineDTO, 
  UpdateMachineDTO,
  UpsertMachineDTO,
  FilterableMachineProps 
} from "./types"

type InjectedDependencies = {
  baseRepository: DAL.RepositoryService
  machineService: ModulesSdkTypes.IMedusaInternalService<any>
}

export class MachinesModuleService
  extends MedusaService<{
    Machine: { dto: MachineDTO }
  }>({
    Machine,
  })
{
  protected baseRepository_: DAL.RepositoryService
  protected machineService_: ModulesSdkTypes.IMedusaInternalService<
    InferEntityType<typeof Machine>
  >

  constructor(
    {
      baseRepository,
      machineService,
    }: InjectedDependencies,
    protected readonly moduleDeclaration: InternalModuleDeclaration
  ) {
    // @ts-ignore
    super(...arguments)

    this.baseRepository_ = baseRepository
    this.machineService_ = machineService
  }

  __joinerConfig(): ModuleJoinerConfig {
    return joinerConfig
  }

  // The following methods are generated by MedusaService:
  // - retrieveMachine(id, config, sharedContext)
  // - listMachines(filters, config, sharedContext) 
  // - listAndCountMachines(filters, config, sharedContext)
  // - createMachines(data, sharedContext)
  // - updateMachines(selector, data, sharedContext)
  // - deleteMachines(ids, sharedContext)

  // Custom business logic methods can be added here
  @InjectManager()
  async getMachinesByCustomer(
    customerId: string,
    config?: any,
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO[]> {
    return await this.listMachines(
      { customer_id: customerId },
      config,
      sharedContext
    )
  }

  @InjectManager()
  async getMachinesByStatus(
    status: "active" | "inactive" | "maintenance" | "sold",
    config?: any,
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO[]> {
    return await this.listMachines(
      { status },
      config,
      sharedContext
    )
  }

  @InjectManager()
  async getMachinesByLocation(
    location: string,
    config?: any,
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO[]> {
    return await this.listMachines(
      { location },
      config,
      sharedContext
    )
  }

  @InjectManager()
  async getMachinesByBrand(
    brandId: string,
    config?: any,
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO[]> {
    return await this.listMachines(
      { brand_id: brandId },
      config,
      sharedContext
    )
  }

  @InjectManager()
  async updateMachineStatus(
    machineId: string,
    status: "active" | "inactive" | "maintenance" | "sold",
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO> {
    const machines = await this.updateMachines(
      { id: machineId },
      { status },
      sharedContext
    )
    return Array.isArray(machines) ? machines[0] : machines
  }

  @InjectManager()
  async searchMachines(
    searchTerm: string,
    config?: any,
    @MedusaContext() sharedContext: Context = {}
  ): Promise<MachineDTO[]> {
    const filters = {
      $or: [
        { model_number: { $ilike: `%${searchTerm}%` } },
        { serial_number: { $ilike: `%${searchTerm}%` } },
        { description: { $ilike: `%${searchTerm}%` } },
        { notes: { $ilike: `%${searchTerm}%` } },
      ]
    }
    
    return await this.listMachines(filters, config, sharedContext)
  }
} 

// Export as both default and named export
export default MachinesModuleService 